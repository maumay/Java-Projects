/**
 * 
 */
package xawd.jflow.iterators.factories;

import java.util.Arrays;
import java.util.function.DoubleSupplier;
import java.util.function.DoubleUnaryOperator;
import java.util.function.IntFunction;
import java.util.function.IntSupplier;
import java.util.function.IntToDoubleFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.LongSupplier;
import java.util.function.LongUnaryOperator;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;

import xawd.jflow.iterators.DoubleFlow;
import xawd.jflow.iterators.Flow;
import xawd.jflow.iterators.IntFlow;
import xawd.jflow.iterators.LongFlow;
import xawd.jflow.iterators.impl.ApplicationFlow;
import xawd.jflow.iterators.impl.CyclicFlow;
import xawd.jflow.iterators.impl.FlowFromFunction;
import xawd.jflow.iterators.iterables.DoubleFlowIterable;
import xawd.jflow.iterators.iterables.IntFlowIterable;
import xawd.jflow.iterators.iterables.LongFlowIterable;


/**
 * Static methods for building infinite Flows.
 * 
 * @author ThomasB
 */
public class Repeatedly
{
	private Repeatedly()
	{
	}

	/**
	 * Creates an infinite Flow beginning with the given initial value and followed
	 * by repeated application of the given function to the previous value in the
	 * Flow.
	 * 
	 * @param applicationOperator
	 *            The unary operator which will be applied repeatedly.
	 * @param initialValue
	 *            The first value in the Flow
	 * @return An infinite Flow generated by repeated function application.
	 */
	public static <E> Flow<E> apply(UnaryOperator<E> applicationOperator, E initialValue)
	{
		return new ApplicationFlow.OfObjects<E>(applicationOperator, initialValue);
	}
	
	/**
	 * Build an infinite Flow from a function which generates instances of a
	 * specified type.
	 *
	 * @param <E>
	 *            The target type of the supply function.
	 * @param instanceSupplier
	 *            A supplier of objects.
	 * @return An infinite Flow built from repeatedly calling the supply function.
	 */
	public static <E> Flow<E> call(Supplier<E> instanceSupplier)
	{
		return new FlowFromFunction.OfObject<>(i -> instanceSupplier.get());
	}
	
	/**
	 * Build an infinite Flow from a function which accepts a positive integer
	 * argument representing a sequence index.
	 *
	 * @param <E>
	 *            The target type of the indexing function.
	 * @param indexingFunction
	 *            A function whose domain is the natural numbers.
	 * @return An infinite Flow built from apply the indexing function to each
	 *         natural number in turn.
	 */
	public static <E> Flow<E> index(IntFunction<E> indexingFunction)
	{
		return new FlowFromFunction.OfObject<>(indexingFunction);
	}

	/**
	 * Creates an infinite, continuously looping Flow from an iterable sequence.
	 *
	 * @param <E>
	 *            The upper bound on the type of elements in the source.
	 *
	 * @param source
	 *            The sequence which will be continuously looped over.
	 * @return A Flow which continuously loops through the elements of the source
	 *         sequence.
	 */
	public static <E> Flow<E> cycle(Iterable<? extends E> source)
	{
		return new CyclicFlow.OfObject<>(source::iterator);
	}

	/**
	 * Creates an infinite, continuously looping Flow from a varargs array source.
	 *
	 * @param <E>
	 *            The type of the element which will be repeated.
	 *
	 * @param elements
	 *            The references which will be cycled through.
	 * @return A Flow which indefinitely cycles through the source elements.
	 */
	@SafeVarargs
	public static <E> Flow<E> cycle(E... elements)
	{
		return cycle(Arrays.asList(elements));
	}
	
	
	// Ints
	
	/**
	 * Creates an infinite Flow beginning with the given initial value and followed
	 * by repeated application of the given function to the previous value in the
	 * Flow.
	 * 
	 * @param applicationOperator
	 *            The unary operator which will be applied repeatedly.
	 * @param initialValue
	 *            The first value in the Flow
	 * @return An infinite Flow generated by repeated function application.
	 */
	public static IntFlow applyInts(IntUnaryOperator applicationOperator, int initialValue)
	{
		return new ApplicationFlow.OfInts(applicationOperator, initialValue);
	}
	
	/**
	 * Build an infinite IntFlow from a function which generates primitive ints.
	 *
	 * @param indexingFunction
	 *            A supplier of Ints.
	 * @return An infinite IntFlow built from repeatedly calling the supply
	 *         function.
	 */
	public static IntFlow callInts(IntSupplier indexingFunction)
	{
		return Repeatedly.indexInts(i -> indexingFunction.getAsInt());
	}

	/**
	 * Build an infinite IntFlow from a function which accepts a positive integer
	 * argument representing a sequence index.
	 *
	 * @param indexingFunction
	 *            A function whose domain is the natural numbers.
	 * @return An infinite IntFlow built from apply the indexing function to each
	 *         natural number in turn.
	 */
	public static IntFlow indexInts(final IntUnaryOperator indexingFunction)
	{
		return new FlowFromFunction.OfInt(indexingFunction, -1);
	}
	

	/**
	 * Creates an infinite, continuously looping IntFlow from an iterable sequence
	 * of ints.
	 *
	 * @param source
	 *            The sequence which will be continuously looped over.
	 * @return An IntFlow which continuously loops through the elements of the
	 *         source sequence.
	 */
	public static IntFlow cycleInts(IntFlowIterable source)
	{
		return new CyclicFlow.OfInt(source::iterator);
	}

	/**
	 * Creates an infinite, continuously looping IntFlow from an int array.
	 *
	 * @param source
	 *            The array which will be continuously looped over.
	 * @return An IntFlow which continuously loops through the elements of the
	 *         source array.
	 */
	public static IntFlow cycleInts(int... source)
	{
		return new CyclicFlow.OfInt(() -> Iterate.overInts(source));
	}
	
	// Doubles
	
	/**
	 * Creates an infinite Flow beginning with the given initial value and followed
	 * by repeated application of the given function to the previous value in the
	 * Flow.
	 * 
	 * @param applicationOperator
	 *            The unary operator which will be applied repeatedly.
	 * @param initialValue
	 *            The first value in the Flow
	 * @return An infinite Flow generated by repeated function application.
	 */
	public static DoubleFlow applyDoubles(DoubleUnaryOperator applicationOperator, double initialValue)
	{
		return new ApplicationFlow.OfDoubles(applicationOperator, initialValue);
	}
	
	/**
	 * Build an infinite DoubleFlow from a function which generates primitive doubles.
	 *
	 * @param indexingFunction
	 *            A supplier of Doubles.
	 * @return An infinite DoubleFlow built from repeatedly calling the supply
	 *         function.
	 */
	public static DoubleFlow callDoubles(final DoubleSupplier indexingFunction)
	{
		return Repeatedly.indexDoubles(i -> indexingFunction.getAsDouble());
	}

	/**
	 * Build an infinite DoubleFlow from a function which accepts a positive integer
	 * argument representing a sequence index.
	 *
	 * @param indexingFunction
	 *            A function whose domain is the natural numbers.
	 * @return An infinite DoubleFlow built from apply the indexing function to each
	 *         natural number in turn.
	 */
	public static DoubleFlow indexDoubles(final IntToDoubleFunction indexingFunction)
	{
		return new FlowFromFunction.OfDouble(indexingFunction, -1);
	}

	/**
	 * Creates an infinite, continuously looping DoubleFlow from an iterable
	 * sequence of doubles.
	 *
	 * @param source
	 *            The sequence which will be continuously looped over.
	 * @return An DoubleFlow which continuously loops through the elements of the
	 *         source sequence.
	 */
	public static DoubleFlow cycleDoubles(DoubleFlowIterable source)
	{
		return new CyclicFlow.OfDouble(source::iterator);
	}

	/**
	 * Creates an infinite, continuously looping DoubleFlow from an double array.
	 *
	 * @param source
	 *            The array which will be continuously looped over.
	 * @return An DoubleFlow which continuously loops through the elements of the
	 *         source array.
	 */
	public static DoubleFlow cycleDoubles(double... source)
	{
		return new CyclicFlow.OfDouble(() -> Iterate.overDoubles(source));
	}
	
	// Longs
	
	/**
	 * Creates an infinite Flow beginning with the given initial value and followed
	 * by repeated application of the given function to the previous value in the
	 * Flow.
	 * 
	 * @param applicationOperator
	 *            The unary operator which will be applied repeatedly.
	 * @param initialValue
	 *            The first value in the Flow
	 * @return An infinite Flow generated by repeated function application.
	 */
	public static LongFlow applyLongs(LongUnaryOperator applicationOperator, long initialValue)
	{
		return new ApplicationFlow.OfLongs(applicationOperator, initialValue);
	}

	/**
	 * Build an infinite LongFlow from a function which generates primitive longs.
	 *
	 * @param longSupplier
	 *            A supplier of longs.
	 * @return An infinite LongFlow built from repeatedly calling the supply
	 *         function.
	 */
	public static LongFlow callLongs(LongSupplier longSupplier)
	{
		return Repeatedly.indexLongs(i -> longSupplier.getAsLong());
	}

	/**
	 * Build an infinite LongFlow from a function which accepts a positive integer
	 * argument representing a sequence index.
	 *
	 * @param indexingFunction
	 *            A function whose domain is the natural numbers.
	 * @return An infinite LongFlow built from apply the indexing function to each
	 *         natural number in turn.
	 */
	public static LongFlow indexLongs(IntToLongFunction indexingFunction)
	{
		return new FlowFromFunction.OfLong(indexingFunction, -1);
	}

	/**
	 * Creates an infinite, continuously looping LongFlow from an iterable sequence
	 * of longs.
	 *
	 * @param source
	 *            The sequence which will be continuously looped over.
	 * @return An LongFlow which continuously loops through the elements of the
	 *         source sequence.
	 */
	public static LongFlow cycleLongs(LongFlowIterable source)
	{
		return new CyclicFlow.OfLong(source::iterator);
	}

	/**
	 * Creates an infinite, continuously looping LongFlow from an long array.
	 *
	 * @param source
	 *            The array which will be continuously looped over.
	 * @return An LongFlow which continuously loops through the elements of the
	 *         source array.
	 */
	public static LongFlow cycleLongs(long... source)
	{
		return new CyclicFlow.OfLong(() -> Iterate.overLongs(source));
	}
}
